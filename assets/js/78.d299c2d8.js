(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{732:function(v,_,t){"use strict";t.r(_);var s=t(3),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("ul",[t("li",[t("h3",{attrs:{id:"js事件委托"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js事件委托"}},[v._v("#")]),v._v(" js事件委托")])])]),v._v(" "),t("p",[v._v("给同层次的所有元素的共同的祖先节点添加一个事件处理程序，而不用给每一个")]),v._v(" "),t("p",[v._v("元素都添加事件处理")]),v._v(" "),t("ul",[t("li",[t("h3",{attrs:{id:"闭包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[v._v("#")]),v._v(" 闭包")])])]),v._v(" "),t("p",[t("strong",[v._v("闭包")]),v._v("指的是引用了另一个函数作用域中变量的"),t("strong",[v._v("函数")]),v._v("，通常是在嵌套函数中实现的。")]),v._v(" "),t("p",[t("em",[t("strong",[v._v("由于闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭包可能导致内存过渡占用")])])]),v._v(" "),t("ul",[t("li",[t("h3",{attrs:{id:"移动端适配的方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#移动端适配的方案"}},[v._v("#")]),v._v(" 移动端适配的方案")])])]),v._v(" "),t("p",[v._v("移动端web页面的开发，由于手机"),t("strong",[v._v("屏幕尺寸")]),v._v("、"),t("strong",[v._v("分辨率")]),v._v("不同，或者需要考虑"),t("strong",[v._v("横竖屏")]),v._v("问题，为了使得web页面在不同移动设备上具有相适应的展示效果，需要在开发过程中使用合理的适配方案来解决这个问题。")]),v._v(" "),t("p",[v._v("方法一："),t("strong",[v._v("rem")])]),v._v(" "),t("ol",[t("li",[v._v("给根节点设置一个字体大小")]),v._v(" "),t("li",[v._v("然后，其他尺寸单位全部用 "),t("strong",[v._v("rem")])]),v._v(" "),t("li",[v._v("监听屏幕的大小")]),v._v(" "),t("li",[v._v("根据屏幕的大小"),t("strong",[v._v("按比例改变")]),v._v("根节点字体的大小")])]),v._v(" "),t("p",[v._v("方法二:"),t("strong",[v._v("媒体查询")]),v._v(" "),t("strong",[v._v("(@media)")])]),v._v(" "),t("p",[v._v("@media起到的作用是，你可以"),t("strong",[v._v("给不同尺寸的设备，设置单独、互不影响的 css 属性")]),v._v("。")]),v._v(" "),t("p",[v._v("比如：屏幕宽度小于 500px 时（手机屏幕），怎样怎样\n宽度在 500px ～ 1000px 时（平板屏幕），怎样怎样\n宽度在 1000px ～ 1500px 时（电脑小屏幕），怎样怎样\n宽度在 1500px ～ 2000px 时（普通电脑屏幕），怎样怎样")]),v._v(" "),t("ul",[t("li",[t("h3",{attrs:{id:"立即执行函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#立即执行函数"}},[v._v("#")]),v._v(" "),t("strong",[v._v("立即执行函数")])]),v._v(" "),t("p",[v._v("(有多种写法：(function(){} )()、( function(){} ())、!function(){}()、)")])])]),v._v(" "),t("p",[v._v("作用：1. 页面加载完成后"),t("strong",[v._v("只执行一次")]),v._v("的设置函数 2. 将设置函数中的变量包裹在局部作用域中，不会泄露成全局变量。 3. 创建一个"),t("strong",[v._v("独立的作用域")]),v._v("，这个作用域里的变量，外面访问不到("),t("strong",[v._v("避免变量污染")]),v._v(")")]),v._v(" "),t("ul",[t("li",[t("h3",{attrs:{id:"js的this指向性问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js的this指向性问题"}},[v._v("#")]),v._v(" js的"),t("strong",[v._v("this指向性")]),v._v("问题")])])]),v._v(" "),t("ol",[t("li",[t("p",[v._v("对于"),t("strong",[v._v("普通函数")]),v._v("来说，this指向的是其调用者，对于箭头函数来说this指向的是调用者的父级")])]),v._v(" "),t("li",[t("p",[v._v("对于"),t("strong",[v._v("匿名函数")]),v._v("来说，this指向的是window,原因是，匿名函数的执行环境是全局的，而且this只在函数内部起作用。在匿名函数中找不到相应内容，所以就从全局中找，找到后打印出来。")])]),v._v(" "),t("li",[t("p",[v._v("对于"),t("strong",[v._v("箭头函数")]),v._v("来说，this指向的是其父级的调用者。")])])]),v._v(" "),t("ul",[t("li",[t("h3",{attrs:{id:"浏览器渲染页面的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染页面的过程"}},[v._v("#")]),v._v(" "),t("strong",[v._v("浏览器渲染页面")]),v._v("的过程")])])]),v._v(" "),t("ol",[t("li",[t("p",[v._v("根据html文件"),t("strong",[v._v("构建DOM树")]),v._v("和"),t("strong",[v._v("CSSOM树")]),v._v("。如果遇到js，阻塞DOM树及CSSOM树的构建，优先加载js文件，加载完毕再继续构建DOM树及CSSOM树；"),t("strong",[v._v("DOM树构建过程")]),v._v("："),t("strong",[v._v("读取html文档，将字节转换成字符，确定tokens（标签），再将tokens转换成节点，以节点构建 DOM 树")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("构建"),t("strong",[v._v("渲染树(Render Tree)")]),v._v(";//"),t("strong",[v._v("细说")]),v._v("：渲染树（Render Tree）"),t("strong",[v._v("由DOM树")]),v._v("、"),t("strong",[v._v("CSSOM树")]),v._v("合并而成，并不是必须等DOM树及CSSOM树加载完成后才开始合并构建渲染树。"),t("strong",[v._v("三者的构建并无先后")]),v._v("条件，亦非完全独立，而是会有交叉，并行构建。因此会形成一边加载，一边解析，一边渲染的工作现象。")])]),v._v(" "),t("li",[t("p",[v._v("页面的重绘(repaint)与重排(reflow)页面渲染完成后，若JS操作了DOM节点，根据JS对DOM操作动作的大小，浏览器对页面进行重绘或是重排。")])])]),v._v(" "),t("ul",[t("li",[t("h3",{attrs:{id:"vue中for循环的key的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue中for循环的key的作用"}},[v._v("#")]),v._v(" vue中"),t("strong",[v._v("for循环的key")]),v._v("的作用")])])]),v._v(" "),t("p",[v._v("key绑定的值不同，所对应的组件中对遍历的列表进行修改时性能会不同，不建议把key绑定至数组的index下，建议绑定在数组内容中某个可以标识内容的值，提高数组渲染的性能。")]),v._v(" "),t("ul",[t("li",[t("h3",{attrs:{id:"vue组件生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue组件生命周期"}},[v._v("#")]),v._v(" "),t("strong",[v._v("vue组件生命周期")])])])]),v._v(" "),t("p",[v._v("beforeCreate:创建空的vue实例，data和methods中的数据未被初始化；")]),v._v(" "),t("p",[v._v("Created: data和methods中的数据初始化完成，可以开始使用data和methods进行一些初始操作")]),v._v(" "),t("p",[v._v("beforeMount: vue组件的模板编译完成，并存放于内存中，但尚未挂载和渲染至页面")]),v._v(" "),t("p",[v._v("mounted: 将内存中编译好的模板进行挂载，并渲染至页面中")])])}),[],!1,null,null,null);_.default=r.exports}}]);